<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ProfileLikelihood.jl</title><meta name="title" content="Docstrings · ProfileLikelihood.jl"/><meta property="og:title" content="Docstrings · ProfileLikelihood.jl"/><meta property="twitter:title" content="Docstrings · ProfileLikelihood.jl"/><meta name="description" content="Documentation for ProfileLikelihood.jl."/><meta property="og:description" content="Documentation for ProfileLikelihood.jl."/><meta property="twitter:description" content="Documentation for ProfileLikelihood.jl."/><meta property="og:url" content="https://DanielVandH.github.io/ProfileLikelihood.jl/docstrings/"/><meta property="twitter:url" content="https://DanielVandH.github.io/ProfileLikelihood.jl/docstrings/"/><link rel="canonical" href="https://DanielVandH.github.io/ProfileLikelihood.jl/docstrings/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ProfileLikelihood.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li class="is-active"><a class="tocitem" href>Docstrings</a><ul class="internal"><li><a class="tocitem" href="#LikelihoodProblem"><span>LikelihoodProblem</span></a></li><li><a class="tocitem" href="#LikelihoodSolution"><span>LikelihoodSolution</span></a></li><li><a class="tocitem" href="#ProfileLikelihoodSolution"><span>ProfileLikelihoodSolution</span></a></li><li><a class="tocitem" href="#BivariateProfileLikelihoodSolution"><span>BivariateProfileLikelihoodSolution</span></a></li><li><a class="tocitem" href="#Prediction-intervals"><span>Prediction intervals</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#GridSearch"><span>GridSearch</span></a></li></ul></li><li><a class="tocitem" href="../regression/">Example I: Multiple linear regression</a></li><li><a class="tocitem" href="../logistic/">Example II: Logistic ordinary differential equation</a></li><li><a class="tocitem" href="../exponential/">Example III: Linear exponential ODE and grid searching</a></li><li><a class="tocitem" href="../lotka/">Example IV: Lotka-Volterra ODE and computing bivarate profile likelihoods</a></li><li><a class="tocitem" href="../stefan/">Example V: Fisher-Stefan PDE</a></li><li><a class="tocitem" href="../math/">Mathematical and Implementation Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/main/docs/src/docstrings.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h1><p>Here we give some of the main docstrings. </p><h2 id="LikelihoodProblem"><a class="docs-heading-anchor" href="#LikelihoodProblem">LikelihoodProblem</a><a id="LikelihoodProblem-1"></a><a class="docs-heading-anchor-permalink" href="#LikelihoodProblem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.AbstractLikelihoodProblem" href="#ProfileLikelihood.AbstractLikelihoodProblem"><code>ProfileLikelihood.AbstractLikelihoodProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLikelihoodProblem{N, L}</code></pre><p>Abstract type of a likelihood problem, where <code>N</code> is the number of parameters and  <code>L</code> is the type of the likelihood function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/abstract_type_definitions.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.LikelihoodProblem" href="#ProfileLikelihood.LikelihoodProblem"><code>ProfileLikelihood.LikelihoodProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LikelihoodProblem{N,P,D,L,Θ,S} &lt;: AbstractLikelihoodProblem</code></pre><p>Struct representing a likelihood problem. </p><p><strong>Fields</strong></p><ul><li><code>problem::P</code></li></ul><p>The associated <code>OptimizationProblem</code>.</p><ul><li><code>data::D</code></li></ul><p>The argument <code>p</code> used in the log-likelihood function. </p><ul><li><code>log_likelihood_function::L</code></li></ul><p>The log-likelihood function, taking the form <code>ℓ(θ, p)</code>.</p><ul><li><code>θ₀::Θ</code></li></ul><p>Initial estimates for the MLE <code>θ</code>.</p><ul><li><code>syms::S</code></li></ul><p>Variable names for the parameters.</p><p>The extra parameter <code>N</code> is the number of parameters.</p><p><strong>Constructors</strong></p><p><strong>Standard</strong></p><pre><code class="nohighlight hljs">LikelihoodProblem(loglik::Function, θ₀;
    syms=eachindex(θ₀), data=SciMLBase.NullParameters(),
    f_kwargs=nothing, prob_kwargs=nothing)</code></pre><p>Constructor for the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>loglik::Function</code>: The log-likelihood function, taking the form <code>ℓ(θ, p)</code>.</li><li><code>θ₀</code>: The estimates estimates for the MLEs.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>syms=eachindex(θ₀)</code>: Names for each parameter. </li><li><code>data=SciMLBase.NullParameters()</code>: The parameter <code>p</code> in the log-likelihood function. </li><li><code>f_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationFunction</code>.</li><li><code>prob_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationProblem</code>.</li></ul><p><strong>Outputs</strong></p><p>Returns the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> problem object.</p><p><strong>With arguments for a differential equation problem</strong></p><pre><code class="nohighlight hljs">LikelihoodProblem(loglik::Function, θ₀,
    ode_function, u₀, tspan;
    syms=eachindex(θ₀), data=SciMLBase.NullParameters(),
    ode_parameters=SciMLBase.NullParameters(), ode_alg,
    ode_kwargs=nothing, f_kwargs=nothing, prob_kwargs=nothing)</code></pre><p>Constructor for the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> for a differential equation problem.</p><p><strong>Arguments</strong></p><ul><li><code>loglik::Function</code>: The log-likelihood function, taking the form <code>ℓ(θ, p, integrator)</code>.</li><li><code>θ₀</code>: The estimates estimates for the MLEs.</li><li><code>ode_function</code>: The function <code>f(du, u, p, t)</code> or <code>f(u, p, t)</code> for the differential equation.</li><li><code>u₀</code>: The initial condition for the differential equation. </li><li><code>tspan</code>: The time-span to solve the differential equation over. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>syms=eachindex(θ₀)</code>: Names for each parameter. </li><li><code>data=SciMLBase.NullParameters()</code>: The parameter <code>p</code> in the log-likelihood function. </li><li><code>ode_parameters=SciMLBase.NullParameters()</code>: The parameter <code>p</code> in <code>ode_function</code>.</li><li><code>ode_alg</code>: The algorithm used for solving the differential equatios.</li><li><code>ode_kwargs=nothing</code>: Extra keyword arguments, passed as a <code>NamedTuple</code>, to pass into the integrator; see <code>construct_integrator</code>.</li><li><code>f_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationFunction</code>.</li><li><code>prob_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationProblem</code>.</li></ul><p><strong>Outputs</strong></p><p>Returns the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> problem object.</p><p><strong>With an integrator</strong></p><pre><code class="nohighlight hljs">LikelihoodProblem(loglik::Function, θ₀, integrator;
    syms=eachindex(θ₀), data=SciMLBase.NullParameters(),
    f_kwargs=nothing, prob_kwargs=nothing)</code></pre><p>Constructor for the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> for a differential equation problem  with associated <code>integrator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>loglik::Function</code>: The log-likelihood function, taking the form <code>ℓ(θ, p, integrator)</code>.</li><li><code>θ₀</code>: The estimates estimates for the MLEs.</li><li><code>integrator</code>: The integrator for the differential equation problem. See also <code>construct_integrator</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>syms=eachindex(θ₀)</code>: Names for each parameter. </li><li><code>data=SciMLBase.NullParameters()</code>: The parameter <code>p</code> in the log-likelihood function. </li><li><code>f_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationFunction</code>.</li><li><code>prob_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationProblem</code>.</li></ul><p><strong>Outputs</strong></p><p>Returns the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> problem object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/likelihood_problem.jl#L9-L106">source</a></section></article><h2 id="LikelihoodSolution"><a class="docs-heading-anchor" href="#LikelihoodSolution">LikelihoodSolution</a><a id="LikelihoodSolution-1"></a><a class="docs-heading-anchor-permalink" href="#LikelihoodSolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.AbstractLikelihoodSolution" href="#ProfileLikelihood.AbstractLikelihoodSolution"><code>ProfileLikelihood.AbstractLikelihoodSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLikelihoodSolution{N, P}</code></pre><p>Type representing the solution to a likelihood problem, where <code>N</code> is the  number of parameters and <code>P</code> is the type of the likelihood problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/abstract_type_definitions.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.LikelihoodSolution" href="#ProfileLikelihood.LikelihoodSolution"><code>ProfileLikelihood.LikelihoodSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LikelihoodSolution{Θ,P,M,R,A} &lt;: AbstractLikelihoodSolution</code></pre><p>Struct for a solution to a <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>mle::Θ</code>: The MLEs.</li><li><code>problem::P</code>: The <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</li><li><code>optimiser::A</code>: The algorithm used for solving the optimisation problem. </li><li><code>maximum::M</code>: The maximum likelihood. </li><li><code>retcode::R</code>: The <code>SciMLBase.ReturnCode</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">LikelihoodSolution(sol::SciMLBase.OptimizationSolution, prob::AbstractLikelihoodProblem; alg=sol.alg)</code></pre><p>Constructs the likelihood solution from a solution to an <code>OptimizationProblem</code> with a given <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/likelihood_solution.jl#L8-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.mle" href="#ProfileLikelihood.mle"><code>ProfileLikelihood.mle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mle(prob::LikelihoodProblem, alg, args...; kwargs...)
mle(prob::LikelihoodProblem, alg::Tuple, args...; kwargs...)</code></pre><p>Given the likelihood problem <code>prob</code> and an optimiser <code>alg</code>, finds the MLEs and returns a  <a href="#ProfileLikelihood.LikelihoodSolution"><code>LikelihoodSolution</code></a> object. Extra arguments and keyword arguments for <code>solve</code> can be passed  through <code>args...</code> and <code>kwargs...</code>.</p><p>If <code>alg</code> is a <code>Tuple</code>, then the problem is re-optimised after each algorithm with the next element in alg,  starting from <code>alg[1]</code>, with initial estimate coming from the solution with the  previous algorithm (starting with <code>get_initial_estimate(prob)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/mle.jl#L1-L12">source</a></section></article><h2 id="ProfileLikelihoodSolution"><a class="docs-heading-anchor" href="#ProfileLikelihoodSolution">ProfileLikelihoodSolution</a><a id="ProfileLikelihoodSolution-1"></a><a class="docs-heading-anchor-permalink" href="#ProfileLikelihoodSolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.ProfileLikelihoodSolution" href="#ProfileLikelihood.ProfileLikelihoodSolution"><code>ProfileLikelihood.ProfileLikelihoodSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProfileLikelihoodSolution{I,V,LP,LS,Spl,CT,CF,OM}</code></pre><p>Struct for the normalised profile log-likelihood. See <a href="#ProfileLikelihood.profile"><code>profile</code></a> for a constructor.</p><p><strong>Fields</strong></p><ul><li><code>parameter_values::Dict{I, V}</code></li></ul><p>This is a dictionary such that <code>parameter_values[i]</code> gives the parameter values used for the normalised profile log-likelihood of the <code>i</code>th variable.</p><ul><li><code>profile_values::Dict{I, V}</code></li></ul><p>This is a dictionary such that <code>profile_values[i]</code> gives the values of the normalised profile log-likelihood function at the corresponding values in <code>θ[i]</code>.</p><ul><li><code>likelihood_problem::LP</code></li></ul><p>The original <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</p><ul><li><code>likelihood_solution::LS</code></li></ul><p>The solution to the full problem.</p><ul><li><code>splines::Dict{I, Spl}</code></li></ul><p>This is a dictionary such that <code>splines[i]</code> is a spline through the data <code>(parameter_values[i], profile_values[i])</code>. This spline can be evaluated at a point <code>ψ</code> for the <code>i</code>th variable by calling an instance of the struct with arguments <code>(ψ, i)</code>. See also <code>spline_profile</code>.</p><ul><li><code>confidence_intervals::Dict{I,ConfidenceInterval{CT,CF}}</code></li></ul><p>This is a dictonary such that <code>confidence_intervals[i]</code> is a confidence interval for the <code>i</code>th parameter.</p><ul><li><code>other_mles::OM</code></li></ul><p>This is a dictionary such that <code>other_mles[i]</code> gives the vector for the MLEs of the other parameters not being profiled, for each datum.</p><p><strong>Spline evaluation</strong></p><p>This struct is callable. We define the method </p><pre><code class="nohighlight hljs">(prof::ProfileLikelihoodSolution)(θ, i)</code></pre><p>that evaluates the spline through the <code>i</code>th profile at the point <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/profile_likelihood_solution.jl#L6-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.ConfidenceInterval" href="#ProfileLikelihood.ConfidenceInterval"><code>ProfileLikelihood.ConfidenceInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConfidenceInterval{T, F}</code></pre><p>Struct representing a confidence interval. </p><p><strong>Fields</strong></p><ul><li><code>lower::T</code></li></ul><p>The lower bound of the confidence interval. </p><ul><li><code>upper::T</code></li></ul><p>The upper bound of the confidence interval. </p><ul><li><code>level::F</code></li></ul><p>The level of the confidence interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/confidence_interval.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.profile" href="#ProfileLikelihood.profile"><code>ProfileLikelihood.profile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">profile(prob::LikelihoodProblem, sol::LikelihoodSolution, n=1:number_of_parameters(prob);
    alg=get_optimiser(sol),
    conf_level::F=0.95,
    confidence_interval_method=:spline,
    threshold=get_chisq_threshold(conf_level),
    resolution=200,
    param_ranges=construct_profile_ranges(sol, get_lower_bounds(prob), get_upper_bounds(prob), resolution),
    min_steps=10,
    normalise::Bool=true,
    spline_alg=FritschCarlsonMonotonicInterpolation,
    extrap=Line,
    parallel=false,
    next_initial_estimate_method = :prev,
    kwargs...)</code></pre><p>Computes profile likelihoods for the parameters from a likelihood problem <code>prob</code> with MLEs <code>sol</code>.</p><p>See also <a href="#ProfileLikelihood.replace_profile!"><code>replace_profile!</code></a> which allows you to re-profile a parameter in case you are not satisfied with  the results. For plotting, see the <code>plot_profiles</code> function (requires that you have loaded CairoMakie.jl and  LaTeXStrings.jl to access the function).</p><p><strong>Arguments</strong></p><ul><li><code>prob::LikelihoodProblem</code>: The <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</li><li><code>sol::LikelihoodSolution</code>: The <a href="#ProfileLikelihood.LikelihoodSolution"><code>LikelihoodSolution</code></a>. See also <a href="#ProfileLikelihood.mle"><code>mle</code></a>.</li><li><code>n=1:number_of_parameters(prob)</code>: The parameter indices to compute the profile likelihoods for.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>alg=get_optimiser(sol)</code>: The optimiser to use for solving each optimisation problem. </li><li><code>conf_level::F=0.95</code>: The level to use for the <a href="#ProfileLikelihood.ConfidenceInterval"><code>ConfidenceInterval</code></a>s.</li><li><code>confidence_interval_method=:spline</code>: The method to use for computing the confidence intervals. See also <a href="#ProfileLikelihood.get_confidence_intervals!"><code>get_confidence_intervals!</code></a>. The default <code>:spline</code> uses rootfinding on the spline through the data, defining a continuous function, while the alternative <code>:extrema</code> simply takes the extrema of the values that exceed the threshold.</li><li><code>threshold=get_chisq_threshold(conf_level)</code>: The threshold to use for defining the confidence intervals. </li><li><code>resolution=200</code>: The number of points to use for evaluating the profile likelihood in each direction starting from the MLE (giving a total of <code>2resolution</code> points). - <code>resolution=200</code>: The number of points to use for defining <code>grids</code> below, giving the number of points to the left and right of each interest parameter. This can also be a vector, e.g. <code>resolution = [20, 50, 60]</code> will use <code>20</code> points for the first parameter, <code>50</code> for the second, and <code>60</code> for the third. </li><li><code>param_ranges=construct_profile_ranges(sol, get_lower_bounds(prob), get_upper_bounds(prob), resolution)</code>: The ranges to use for each parameter.</li><li><code>min_steps=10</code>: The minimum number of steps to allow for the profile in each direction. If fewer than this number of steps are used before reaching the threshold, then the algorithm restarts and computes the profile likelihood a number <code>min_steps</code> of points in that direction. See also <code>min_steps_fallback</code>.</li><li><code>min_steps_fallback=:replace</code>: Method to use for updating the profile when it does not reach the minimum number of steps, <code>min_steps</code>. See also <a href="#ProfileLikelihood.reach_min_steps!"><code>reach_min_steps!</code></a>. If <code>:replace</code>, then the profile is completely replaced and we use <code>min_steps</code> equally spaced points to replace it. If <code>:refine</code>, we just fill in some of the space in the grid so that a <code>min_steps</code> number of points are reached. Note that this latter option will mean that the spacing is no longer constant between parameter values. You can use <code>:refine_parallel</code> to apply <code>:refine</code> in parallel.</li><li><code>normalise::Bool=true</code>: Whether to optimise the normalised profile log-likelihood or not. </li><li><code>spline_alg=FritschCarlsonMonotonicInterpolation</code>: The interpolation algorithm to use for computing a spline from the profile data. See Interpolations.jl. </li><li><code>extrap=Line</code>: The extrapolation algorithm to use for computing a spline from the profile data. See Interpolations.jl.</li><li><code>parallel=false</code>: Whether to use multithreading. If <code>true</code>, will use multithreading so that multiple parameters are profiled at once, and the steps to the left and right are done at the same time. </li><li><code>next_initial_estimate_method = :prev</code>: Method for selecting the next initial estimate when stepping forward when profiling. <code>:prev</code> simply uses the previous solution, but you can also use <code>:interp</code> to use linear interpolation. See also <a href="#ProfileLikelihood.set_next_initial_estimate!-NTuple{5, Any}"><code>set_next_initial_estimate!</code></a>.</li><li><code>kwargs...</code>: Extra keyword arguments to pass into <code>solve</code> for solving the <code>OptimizationProblem</code>. See also the docs from Optimization.jl.</li></ul><p><strong>Output</strong></p><p>Returns a <a href="#ProfileLikelihood.ProfileLikelihoodSolution"><code>ProfileLikelihoodSolution</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/profile_likelihood.jl#L3-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.replace_profile!" href="#ProfileLikelihood.replace_profile!"><code>ProfileLikelihood.replace_profile!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replace_profile!(prof::ProfileLikelihoodSolution, n);
    alg=get_optimiser(prof.likelihood_solution),
    conf_level::F=0.95,
    confidence_interval_method=:spline,
    threshold=get_chisq_threshold(conf_level),
    resolution=200,
    param_ranges=construct_profile_ranges(prof.likelihood_solution, get_lower_bounds(prof.likelihood_problem), get_upper_bounds(prof.likelihood_problem), resolution),
    min_steps=10,
    min_steps_fallback=:replace,
    normalise::Bool=true,
    spline_alg=FritschCarlsonMonotonicInterpolation,
    extrap=Line,
    parallel=false,
    next_initial_estimate_method=:prev,
    kwargs...) where {F}</code></pre><p>Given an existing <code>prof::ProfileLikelihoodSolution</code>, replaces the profile results for the parameters in <code>n</code> by re-profiling. The keyword  arguments are the same as for <a href="#ProfileLikelihood.profile"><code>profile</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/profile_likelihood.jl#L100-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.refine_profile!" href="#ProfileLikelihood.refine_profile!"><code>ProfileLikelihood.refine_profile!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refine_profile!(prof::ProfileLikelihoodSolution, n;
    alg=get_optimiser(prof.likelihood_solution),
    conf_level::F=0.95,
    confidence_interval_method=:spline,
    threshold=get_chisq_threshold(conf_level),
    target_number=10,
    normalise::Bool=true,
    spline_alg=FritschCarlsonMonotonicInterpolation,
    extrap=Line,
    parallel=false,
    kwargs...) where {F}</code></pre><p>Given an existing <code>prof::ProfileLikelihoodSolution</code>, refines the profile results for the parameters in <code>n</code> by adding more points. The keyword  arguments are the same as for <a href="#ProfileLikelihood.profile"><code>profile</code></a>. <code>target_number</code> is the total number of points that should be included in the end (not how many more  are added).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/profile_likelihood.jl#L150-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.set_next_initial_estimate!-NTuple{5, Any}" href="#ProfileLikelihood.set_next_initial_estimate!-NTuple{5, Any}"><code>ProfileLikelihood.set_next_initial_estimate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_next_initial_estimate!(sub_cache, param_vals, other_mles, prob, θₙ; next_initial_estimate_method=Val(:prev))</code></pre><p>Method for selecting the next initial estimate for the optimisers. <code>sub_cache</code> is the cache vector for placing  the initial estimate into, <code>param_vals</code> is the current list of parameter values for the interest parameter,  and <code>other_mles</code> is the corresponding list of previous optimisers. <code>prob</code> is the <code>OptimizationProblem</code>. The value  <code>θₙ</code> is the next value of the interest parameter.</p><p>The available methods are: </p><ul><li><code>next_initial_estimate_method = Val(:prev)</code>: If this is selected, simply use <code>other_mles[end]</code>, i.e. the previous optimiser. </li><li><code>next_initial_estimate_method = Val(:interp)</code>: If this is selected, the next optimiser is determined via linear interpolation using the data <code>(param_vals[end-1], other_mles[end-1]), (param_vals[end], other_mles[end])</code>. If the new approximation is outside of the parameter bounds, falls back to <code>next_initial_estimate_method = :prev</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/profile_likelihood.jl#L336-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.get_confidence_intervals!" href="#ProfileLikelihood.get_confidence_intervals!"><code>ProfileLikelihood.get_confidence_intervals!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_confidence_intervals!(confidence_intervals, method, n, param_vals, profile_vals, threshold, spline_alg, extrap, mles, conf_level)</code></pre><p>Method for computing the confidence intervals.</p><p><strong>Arguments</strong></p><ul><li><p><code>confidence_intervals</code>: The dictionary storing the confidence intervals. </p></li><li><p><code>method</code>: The method to use for computing the confidence interval. The available methods are:</p><ul><li><code>method = Val(:spline)</code>: Fits a spline to <code>(param_vals, profile_vals)</code> and finds where the continuous spline equals <code>threshold</code>.</li><li><code>method = Val(:extrema)</code>: Takes the first and last values in <code>param_vals</code> whose corresponding value in <code>profile_vals</code> exceeds <code>threshold</code>.</li></ul></li><li><p><code>n</code>: The parameter being profiled. </p></li><li><p><code>param_vals</code>: The parameter values. </p></li><li><p><code>profile_vals</code>: The profile values. </p></li><li><p><code>threshold</code>: The threshold for the confidence interval. </p></li><li><p><code>spline_alg</code>: The algorithm to use for fitting a spline. </p></li><li><p><code>extrap</code>: The extrapolation algorithm used for the spline.</p></li><li><p><code>mles</code>: The MLEs. </p></li><li><p><code>conf_level</code>: The confidence level for the confidence interval.</p></li></ul><p><strong>Outputs</strong></p><p>There are no outputs - <code>confidence_intervals[n]</code> gets the <a href="#ProfileLikelihood.ConfidenceInterval"><code>ConfidenceInterval</code></a> put into it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/profile_likelihood.jl#L671-L694">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.reach_min_steps!" href="#ProfileLikelihood.reach_min_steps!"><code>ProfileLikelihood.reach_min_steps!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reach_min_steps!(param_vals, profile_vals, other_mles, param_range,
    restricted_prob, n, cache, alg, sub_cache, ℓmax, normalise,
    threshold, min_steps, mles; min_steps_fallback=Val(:replace), next_initial_estimate_method=Val(:interp), kwargs...)</code></pre><p>Updates the results from the side of a profile likelihood (e.g. left or right side, see <code>find_endpoint!</code>) to meet the minimum number of  steps <code>min_steps</code>.</p><p><strong>Arguments</strong></p><ul><li><code>param_vals</code>: The parameter values. </li><li><code>profile_vals</code>: The profile values. </li><li><code>other_mles</code>: The other MLEs, i.e. the optimised parameters for the corresponding fixed parameter values in <code>param_vals</code>.</li><li><code>param_range</code>: The vector of parameter values.</li><li><code>restricted_prob</code>: The optimisation problem, restricted to the <code>n</code>th parameter. </li><li><code>n</code>: The parameter being profiled.</li><li><code>cache</code>: A cache for the complete parameter vector. </li><li><code>alg</code>: The algorithm used for optimising. </li><li><code>sub_cache</code>: A cache for the parameter vector excluding the <code>n</code>th parameter.</li><li><code>ℓmax</code>: The maximum likelihood. </li><li><code>normalise</code>: Whether the optimisation problem is normalised.</li><li><code>threshold</code>: The threshold for the confidence interval. </li><li><code>min_steps</code>: The minimum number of steps to reach. </li><li><code>mles</code>: The MLEs.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>min_steps_fallback=Val(:interp)</code>: The method used for reaching the minimum number of steps. The available methods are:</p><ul><li><code>min_steps_fallback = Val(:replace)</code>: This method completely replaces the profile, defining a grid from the MLE to the computed endpoint with <code>min_steps</code> points. No information is re-used.</li><li><code>min_steps_fallback = Val(:refine)</code>: This method just adds more points to the profile, filling in enough points so that the total number of points is <code>min_steps</code>. The initial estimates in this case come from a spline from <code>other_mles</code>.</li><li><code>min_steps_fallback = Val(:parallel_refine)</code>: This applies the method above, except in parallel. </li></ul></li><li><p><code>next_initial_estimate_method=Val(:replace)</code>: The method used for obtaining initial estimates. See also <a href="#ProfileLikelihood.set_next_initial_estimate!-NTuple{5, Any}"><code>set_next_initial_estimate!</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/profile_likelihood.jl#L458-L490">source</a></section></article><h2 id="BivariateProfileLikelihoodSolution"><a class="docs-heading-anchor" href="#BivariateProfileLikelihoodSolution">BivariateProfileLikelihoodSolution</a><a id="BivariateProfileLikelihoodSolution-1"></a><a class="docs-heading-anchor-permalink" href="#BivariateProfileLikelihoodSolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.BivariateProfileLikelihoodSolution" href="#ProfileLikelihood.BivariateProfileLikelihoodSolution"><code>ProfileLikelihood.BivariateProfileLikelihoodSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BivariateProfileLikelihoodSolution{I,V,LP,LS,Spl,CT,CF,OM}</code></pre><p>Struct for the normalised bivariate profile log-likelihood. See <a href="#ProfileLikelihood.bivariate_profile"><code>bivariate_profile</code></a> for a constructor. </p><p><strong>Arguments</strong></p><ul><li><code>parameter_values::Dict{I, G}</code></li></ul><p>Maps the tuple <code>(i, j)</code> to the grid values used for this parameter pair. The result is a <code>Tuple</code>, with the first element  the grid for the <code>i</code>th parameter, and the second element the grid for the <code>j</code>th parameter. The grids are given as  <code>OffsetVector</code>s, with the <code>0</code>th index the MLE, negative indices to the left of the MLE, and positive indices to the  right of the MLE.</p><ul><li><code>profile_values::Dict{I, V}</code></li></ul><p>Maps the tuple <code>(i, j)</code> to the matrix used for this parameter pair. The result is a <code>OffsetMatrix</code>, with the <code>(k, ℓ)</code> entry  the profile at <code>(parameter_values[(i, j)][1][k], parameter_values[(i, j)][2][k])</code>, and particularly the <code>(0, 0)</code> entry is the  profile at the MLEs.</p><ul><li><code>likelihood_problem::LP</code></li></ul><p>The original likelihood problem. </p><ul><li><code>likelihood_solution::LS</code></li></ul><p>The original likelihood solution. </p><ul><li><code>interpolants::Dict{I,Spl}</code></li></ul><p>Maps the tuple <code>(i, j)</code> to the interpolant for that parameter pair&#39;s profile. This interpolant also uses linear extrapolation. </p><ul><li><code>confidence_regions::Dict{I,ConfidenceRegion{CT,CF}}</code></li></ul><p>Maps the tuple <code>(i, j)</code> to the confidence region for that parameter pair&#39;s confidence region. See also <a href="#ProfileLikelihood.ConfidenceRegion"><code>ConfidenceRegion</code></a>.</p><ul><li><code>other_mles::OM</code></li></ul><p>Maps the tuple <code>(i, j)</code> to an <code>OffsetMatrix</code> storing the solutions for the nuisance parameters at the corresponding grid values. </p><p><strong>Interpolant evaluation</strong></p><p>This struct is callable. We define the method </p><pre><code class="nohighlight hljs">(prof::BivariateProfileLikelihoodSolution)(θ, ψ, i, j)</code></pre><p>that evaluates the interpolant through the <code>(i, j)</code>th profile at the point <code>(θ, ψ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/profile_likelihood_solution.jl#L118-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.ConfidenceRegion" href="#ProfileLikelihood.ConfidenceRegion"><code>ProfileLikelihood.ConfidenceRegion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConfidenceRegion{T, F}</code></pre><p>Struct representing a confidence region. </p><p><strong>Fields</strong></p><ul><li><code>x::T</code></li></ul><p>The <code>x</code>-coordinates for the region&#39;s boundary.</p><ul><li><code>y::T</code></li></ul><p>The <code>y</code>-coordinates for the region&#39;s boundary.</p><ul><li><code>level::F</code></li></ul><p>The level of the confidence region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/confidence_interval.jl#L45-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.bivariate_profile" href="#ProfileLikelihood.bivariate_profile"><code>ProfileLikelihood.bivariate_profile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bivariate_profile(prob::LikelihoodProblem, sol::LikelihoodSolution, n::NTuple{M,NTuple{2,Int}};
    alg=get_optimiser(sol),
    conf_level::F=0.95,
    confidence_region_method=Val(:contour),
    threshold=get_chisq_threshold(conf_level, 2),
    resolution=200,
    grids=construct_profile_grids(n, sol, get_lower_bounds(prob), get_upper_bounds(prob), resolution),
    min_layers=10,
    outer_layers=0,
    normalise=Val(true),
    parallel=Val(false),
    next_initial_estimate_method=Val(:nearest),
    kwargs...) where {M,F}</code></pre><p>Computes bivariates profile likelihoods for the parameters from a likelihood problem <code>prob</code> with MLEs <code>sol</code>. You can also call  this function using <code>Symbols</code>, e.g. if <code>get_syms(prob) = [:λ, :K, :u₀]</code>, then calling <code>bivariate_profile(prob, sol, ((:λ, :K), (:K, u₀)))</code> is the same as calling <code>bivariate_profile(prob, sol, ((1, 2), (2, 3)))</code> (the integer coordinate representation is still used in the solution, though).</p><p>For plotting, see the <code>plot_profiles</code> function (requires that you have loaded CairoMakie.jl and  LaTeXStrings.jl to access the function).</p><p><strong>Arguments</strong></p><ul><li><code>prob::LikelihoodProblem</code>: The <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</li><li><code>sol::LikelihoodSolution</code>: The <a href="#ProfileLikelihood.LikelihoodSolution"><code>LikelihoodSolution</code></a>. See also <a href="#ProfileLikelihood.mle"><code>mle</code></a>.</li><li><code>n::NTuple{M,NTuple{2,Int}}</code>: The parameter indices to compute the profile likelihoods for. These should be tuples of indices, e.g. <code>n = ((1, 2),)</code> will compute the bivariate profile between the parameters <code>1</code> and <code>2</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>alg=get_optimiser(sol)</code>: The optimiser to use for solving each optimisation problem. </li><li><code>conf_level::F=0.95</code>: The level to use for the <a href="#ProfileLikelihood.ConfidenceRegion"><code>ConfidenceRegion</code></a>s.</li><li><code>confidence_region_method=:contour</code>: The method to use for computing the confidence regions. See also <code>get_confidence_regions!</code>. The default, <code>:contour</code>, using Contour.jl to compute the boundary of the confidence region. An alternative option is <code>:delaunay</code>, which uses DelaunayTriangulation.jl and triangulation contouring to find the boundary. This latter option is only available if you have already done <code>using DelaunayTriangulation</code>.</li><li><code>threshold=get_chisq_threshold(conf_level, 2)</code>: The threshold to use for defining the confidence regions. </li><li><code>resolution=200</code>: The number of points to use for defining <code>grids</code> below, giving the number of points to the left and right of each interest parameter. This can also be a vector, e.g. <code>resolution = [20, 50, 60]</code> will use <code>20</code> points for the first parameter, <code>50</code> for the second, and <code>60</code> for the third. When defining the grid between pairs of values, the maximum of the two resolutions is used (thus defining a square grid).</li><li><code>grids=construct_profile_grids(n, sol, get_lower_bounds(prob), get_upper_bounds(prob), resolution)</code>: The grids to use for each parameter pair.</li><li><code>min_layers=10</code>: The minimum number of layers to allow for the profile away from the MLE. If fewer than this number of layers are used before reaching the threshold, then the algorithm restarts and computes the profile likelihood a number <code>min_steps</code> of points in that direction. </li><li><code>outer_layers=0</code>: The number of layers to go out away from the bounding box of the confidence region.</li><li><code>normalise=true</code>: Whether to optimise the normalised profile log-likelihood or not. </li><li><code>parallel=false</code>: Whether to use multithreading. If <code>true</code>, will use multithreading so that multiple parameters are profiled at once, and the work done evaluating the solution at each node in a layer is distributed across each thread.</li><li><code>next_initial_estimate_method = :nearest</code>: Method for selecting the next initial estimate when stepping onto the next layer when profiling. <code>:nearest</code> simply uses the solution at the nearest node from the previous layer, but you can also use <code>:mle</code> to reuse the MLE or <code>:interp</code> to use linear interpolation. See also <a href="#ProfileLikelihood.set_next_initial_estimate!-NTuple{5, Any}"><code>set_next_initial_estimate!</code></a>.</li><li><code>kwargs...</code>: Extra keyword arguments to pass into <code>solve</code> for solving the <code>OptimizationProblem</code>. See also the docs from Optimization.jl.</li></ul><p><strong>Output</strong></p><p>Returns a <a href="#ProfileLikelihood.BivariateProfileLikelihoodSolution"><code>BivariateProfileLikelihoodSolution</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/bivariate.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.set_next_initial_estimate!-Union{Tuple{M}, Tuple{Any, Any, CartesianIndex, Any, Any, Any, Any, Val{M}}} where M" href="#ProfileLikelihood.set_next_initial_estimate!-Union{Tuple{M}, Tuple{Any, Any, CartesianIndex, Any, Any, Any, Any, Val{M}}} where M"><code>ProfileLikelihood.set_next_initial_estimate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_next_initial_estimate!(sub_cache, other_mles, I::CartesianIndex, fixed_vals, grid, layer, prob, next_initial_estimate_method::Val{M}) where {M}</code></pre><p>Method for selecting the next initial estimate for the optimisers. </p><p><strong>Arguments</strong></p><ul><li><code>sub_cache</code>: Cache for the next initial estimate. </li><li><code>other_mles</code>: Solutions to the optimisation problems found so far. </li><li><code>I::CartesianIndex</code>: The coordinate of the node currently being considered. </li><li><code>fixed_vals</code>: The current values for the parameters of interest. </li><li><code>grid</code>: The grid for the parameters of interest. </li><li><code>layer</code>: The current layer. </li><li><code>prob</code>: The restricted optimisation problem. </li><li><code>next_initial_estimate_method::Val{M}</code>: The method to use.</li></ul><p>The methods currently available for <code>next_initial_estimate_method</code> are: </p><ul><li><code>next_initial_estimate_method = Val(:mle)</code>: Simply sets <code>sub_cache</code> to be the MLE. </li><li><code>next_initial_estimate_method = Val(:nearest)</code>: Sets <code>sub_cache</code> to be <code>other_mles[J]</code>, where <code>J</code> is the nearest node to <code>I</code> in the previous layer. </li><li><code>next_initial_estimate_method = Val(:interp)</code>: Uses linear interpolation from all the previous layers to extrapolate and compute a new <code>sub_cache</code>.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/bivariate.jl#L363-L386">source</a></section></article><h2 id="Prediction-intervals"><a class="docs-heading-anchor" href="#Prediction-intervals">Prediction intervals</a><a id="Prediction-intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction-intervals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.get_prediction_intervals" href="#ProfileLikelihood.get_prediction_intervals"><code>ProfileLikelihood.get_prediction_intervals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_prediction_intervals(q, prof::(Bivariate)ProfileLikelihoodSolution, data;
    q_prototype=isinplace(q, 3) ? nothing : build_q_prototype(q, prof, data), resolution=250)</code></pre><p>Obtain prediction intervals for the output of the prediction function <code>q</code>, assuming <code>q</code> returns (or operates in-place on) a vector.</p><p><strong>Arguments</strong></p><ul><li><code>q</code>: The prediction function, taking either the form <code>(θ, data)</code> or <code>(cache, θ, data)</code>. The former version is an out-of-place version, returning the full vector, while the latter version is an in-place version, with the output being placed into <code>cache</code>. The argument <code>θ</code> is the same as the parameters used in the likelihood problem (from <code>prof</code>), and the <code>data</code> argument is the same <code>data</code> as in this function. </li><li><code>prof::(Bivariate)ProfileLikelihoodSolution</code>: The profile likelihood results. </li><li><code>data</code>: The argument <code>data</code> in <code>q</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>q_prototype=isinplace(q, 3) ? nothing : build_q_prototype(q, prof, data)</code>: A prototype for the result of <code>q</code>. If you are using the <code>q(θ, data)</code> version of <code>q</code>, this can be inferred from <code>build_q_prototype</code>, but if you are using the in-place version then a <code>build_q_prototype</code> is needed. For example, if <code>q</code> returns a vector with eltype <code>Float64</code> and has length 27, <code>q_prototype</code> could be <code>zeros(27)</code>.</li><li><code>resolution::Integer=250</code>: The amount of curves to evaluate for each parameter. This will be the same for each parameter. If <code>prof isa BivariateProfileLikelihoodSolution</code>, then <code>resolution^2</code> points are defined inside a bounding box for the confidence region, and then we throw away all points outside of the actual confidence region.</li><li><code>parallel=false</code>: Whether to use multithreading. Multithreading is used when building <code>q_vals</code> below.</li></ul><p><strong>Outputs</strong></p><p>Four values are returned. In order: </p><ul><li><code>individual_intervals</code>: Prediction intervals for the output of <code>q</code>, relative to each parameter. </li><li><code>union_intervals</code>: The union of the individual prediction intervals from <code>individual_intervals</code>.</li><li><code>q_vals</code>: Values of <code>q</code> at each parameter considered. The output is a <code>Dict</code>, where the parameter index is mapped to a matrix where each column is an output from <code>q</code>, with the <code>j</code>th column corresponding to the parameter value at <code>param_ranges[j]</code>.</li><li><code>param_ranges</code>: Parameter values used for each prediction interval. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/prediction_intervals.jl#L1-L24">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.plot_profiles" href="#ProfileLikelihood.plot_profiles"><code>ProfileLikelihood.plot_profiles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_profiles(prof::ProfileLikelihoodSolution, vars = profiled_parameters(prof); 
    ncol=nothing, 
    nrow=nothing,
    true_vals=Dict(vars .=&gt; nothing), 
    spline=true, 
    show_mles=true, 
    shade_ci=true, 
    fig_kwargs=nothing, 
    axis_kwargs=nothing,
    show_points=false,
    markersize=9,
    latex_names = Dict(vars .=&gt; [L&quot;	heta_{i}&quot; for i in SciMLBase.sym_to_index.(vars, Ref(prof))]))</code></pre><p>Plot results from a profile likelihood solution <code>prof</code>. To use this function you you need to have done <code>using CairoMakie</code> (or any other Makie backend).</p><p><strong>Arguments</strong></p><ul><li><code>prof::ProfileLikelihoodSolution</code>: The profile likelihood solution from <a href="#ProfileLikelihood.profile"><code>profile</code></a>.</li><li><code>vars = profiled_parameters(prof)</code>: The parameters to plot.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ncol=nothing</code>: The number of columns to use. If <code>nothing</code>, chosen automatically via <code>choose_grid_layout</code>.</li><li><code>nrow=nothing</code>: The number of rows to use. If <code>nothing</code>, chosen automatically via <code>choose_grid_layout</code></li><li><code>true_vals=Dict(vars .=&gt; nothing)</code>: A dictionary mapping parameter indices to their true values, if they exist. If <code>nothing</code>, nothing is plotted, otherwise a black line is plotted at the true value for the profile. </li><li><code>spline=true</code>: Whether the curve plotted should come from a spline through the results, or if the data itself should be plotted. </li><li><code>show_mles=true</code>: Whether to put a red line at the MLEs. </li><li><code>shade_ci=true</code>: Whether to shade the area under the profile between the confidence interval.</li><li><code>fig_kwargs=nothing</code>: Extra keyword arguments for <code>Figure</code> (see the Makie docs).</li><li><code>axis_kwargs=nothing</code>: Extra keyword arguments for <code>Axis</code> (see the Makie docs).</li><li><code>show_points=false</code>: Whether to show the profile data. </li><li><code>markersize=9</code>: The marker size used for <code>show_points</code>.</li><li><code>latex_names = Dict(vars .=&gt; [L&quot;	heta_{i}&quot; for i in SciMLBase.sym_to_index.(vars, Ref(prof))]))</code>: LaTeX names to use for the parameters. Defaults to <code>θᵢ</code>, where <code>i</code> is the index of the parameter. </li></ul><p><strong>Output</strong></p><p>The <code>Figure()</code> is returned.</p><hr/><pre><code class="nohighlight hljs">plot_profiles(prof::BivariateProfileLikelihoodSolution, vars = profiled_parameters(prof); 
    ncol=nothing,
    nrow=nothing,
    true_vals=Dict(1:number_of_parameters(get_likelihood_problem(prof)) .=&gt; nothing),
    show_mles=true,
    fig_kwargs=nothing,
    axis_kwargs=nothing,
    interpolation=false,
    smooth_confidence_boundary=false,
    close_contour=true,
    latex_names=Dict(1:number_of_parameters(get_likelihood_problem(prof)) .=&gt; get_syms(prof)))</code></pre><p>Plot results from a bivariate profile likelihood solution <code>prof</code>. To use this function you you need to have done <code>using CairoMakie</code> (or any other Makie backend).</p><p><strong>Arguments</strong></p><ul><li><code>prof::ProfileLikelihoodSolution</code>: The profile likelihood solution from <a href="#ProfileLikelihood.profile"><code>profile</code></a>.</li><li><code>vars = profiled_parameters(prof)</code>: The parameters to plot.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ncol=nothing</code>: The number of columns to use. If <code>nothing</code>, chosen automatically via <code>choose_grid_layout</code>.</li><li><code>nrow=nothing</code>: The number of rows to use. If <code>nothing</code>, chosen automatically via <code>choose_grid_layout</code></li><li><code>true_vals=Dict(1:number_of_parameters(get_likelihood_problem(prof)) .=&gt; nothing)</code>: A dictionary mapping parameter indices to their true values, if they exist. If <code>nothing</code>, nothing is plotted, otherwise a black dot is plotted at the true value on the bivariate profile&#39;s plot.</li><li><code>show_mles=true</code>: Whether to put a red dot at the MLEs. </li><li><code>fig_kwargs=nothing</code>: Extra keyword arguments for <code>Figure</code> (see the Makie docs).</li><li><code>axis_kwargs=nothing</code>: Extra keyword arguments for <code>Axis</code> (see the Makie docs).</li><li><code>interpolation=false</code>: Whether to plot the profile using the interpolant (<code>true</code>), or to use the data from <code>prof</code> directly (<code>false</code>).</li><li><code>smooth_confidence_boundary=false</code>: Whether to smooth the confidence region boundary when plotting (<code>true</code>) or not (<code>false</code>). The smoothing is done with a spline.</li><li><code>close_contour=true</code>: Whether to connect the last part of the confidence region boundary to the beginning (<code>true</code>) or not (<code>false</code>).</li><li><code>latex_names=Dict(1:number_of_parameters(get_likelihood_problem(prof)) .=&gt; get_syms(prof)))</code>: LaTeX names to use for the parameters. Defaults to the <code>syms</code> names.</li><li><code>xlim_tuples=nothing</code>: <code>xlims</code> to use for each plot. <code>nothing</code> if the <code>xlims</code> should be set automatically.</li><li><code>ylim_tuples=nothing</code>: <code>ylims</code> to use for each plot. <code>nothing</code> if the <code>ylims</code> should be set automatically.</li></ul><p><strong>Output</strong></p><p>The <code>Figure()</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/ProfileLikelihood.jl#L58-L130">source</a></section></article><h2 id="GridSearch"><a class="docs-heading-anchor" href="#GridSearch">GridSearch</a><a id="GridSearch-1"></a><a class="docs-heading-anchor-permalink" href="#GridSearch" title="Permalink"></a></h2><h3 id="Grid-definitions"><a class="docs-heading-anchor" href="#Grid-definitions">Grid definitions</a><a id="Grid-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-definitions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.AbstractGrid" href="#ProfileLikelihood.AbstractGrid"><code>ProfileLikelihood.AbstractGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractGrid{N,B,T}</code></pre><p>Type representing a grid, where <code>N</code> is the number of parameters, <code>B</code> is the type for the  bounds, and <code>T</code> is the number type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/abstract_type_definitions.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.RegularGrid" href="#ProfileLikelihood.RegularGrid"><code>ProfileLikelihood.RegularGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RegularGrid{N,B,R,S,T} &lt;: AbstractGrid{N,B,T}</code></pre><p>Struct for a grid in which each parameter is regularly spaced. </p><p><strong>Fields</strong></p><ul><li><code>lower_bounds::B</code>: Lower bounds for each parameter. </li><li><code>upper_bounds::B</code>: Upper bounds for each parameter. </li><li><code>resolution::R</code>: Number of grid points for each parameter. If <code>R &lt;: Number</code>, then the same number of grid points is used for each parameter. </li><li><code>step_sizes::S</code>: Grid spacing for each parameter. </li></ul><p><strong>Constructor</strong></p><p>You can construct a <code>RegularGrid</code> using <code>RegularGrid(lower_bounds, upper_bounds, resolution)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/grid_search.jl#L4-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.FusedRegularGrid" href="#ProfileLikelihood.FusedRegularGrid"><code>ProfileLikelihood.FusedRegularGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FusedRegularGrid{N,B,R,S,T,C,OR} &lt;: AbstractGrid{N,B,T}</code></pre><p>Struct representing the fusing of two grids.</p><p><strong>Fields</strong></p><ul><li><code>positive_grid::RegularGrid{N,B,R,S,T}</code></li></ul><p>This is the first part of the grid, indexed into by positive integers. </p><ul><li><code>negative_grid::RegularGrid{N,B,R,S,T}</code></li></ul><p>This is the second part of the grid, indexed into by negative integers.</p><ul><li><code>centre::C</code></li></ul><p>The two grids meet at a common centre, and this is that <code>centre</code>. </p><ul><li><code>resolutions::R</code></li></ul><p>This is the vector of resolutions provided (e.g. if <code>store_original_resolutions=true</code> in the constructor below), or the transformed  version from <code>get_resolution_tuples</code>.</p><p><strong>Constructor</strong></p><p>You can construct a <code>FusedRegularGrid</code> using the method</p><pre><code class="nohighlight hljs">FusedRegularGrid(lower_bounds::B, upper_bounds::B, centre::C, resolutions::R; store_original_resolutions=false) where {B,R,C}</code></pre><p>For example, the following code creates <code>fused</code> as the fusion of <code>grid_1</code> and <code>grid_2</code>:</p><pre><code class="language-jula-repl hljs">lb = [2.0, 3.0, 1.0, 5.0]
ub = [15.0, 13.0, 27.0, 10.0]
centre = [7.3, 8.3, 2.3, 7.5]
grid_1 = RegularGrid(centre .+ (ub .- centre) / 173, ub, 173)
grid_2 = RegularGrid(centre .- (centre .- lb) / 173, lb, 173)
fused = ProfileLikelihood.FusedRegularGrid(lb, ub, centre, 173)</code></pre><p>There are <code>173</code> points to the left and right of <code>centre</code> in this case. To use a varying  number of points, use e.g.</p><pre><code class="language-julia-repl hljs">lb = [2.0, 3.0, 1.0, 5.0, 4.0]
ub = [15.0, 13.0, 27.0, 10.0, 13.0]
centre = [7.3, 8.3, 2.3, 7.5, 10.0]
res = [(2, 11), (23, 25), (19, 21), (50, 51), (17, 99)]
grid_1 = RegularGrid(centre .+ (ub .- centre) ./ [2, 23, 19, 50, 17], ub, [2, 23, 19, 50, 17])
grid_2 = RegularGrid(centre .- (centre .- lb) ./ [11, 25, 21, 51, 99], lb, [11, 25, 21, 51, 99])
fused = ProfileLikelihood.FusedRegularGrid(lb, ub, centre, res) # fused grid_1 and grid_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/grid_search.jl#L79-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.IrregularGrid" href="#ProfileLikelihood.IrregularGrid"><code>ProfileLikelihood.IrregularGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IrregularGrid{N,B,R,S,T} &lt;: AbstractGrid{N,B,T}</code></pre><p>Struct for an irregular grid of parameters.</p><p><strong>Fields</strong></p><ul><li><code>lower_bounds::B</code>: Lower bounds for each parameter. </li><li><code>upper_bounds::B</code>: Upper bounds for each parameter. </li><li><code>grid::G</code>: The set of parameter values, e.g. a matrix where each column is the parameter vector.</li></ul><p><strong>Constructor</strong></p><p>You can construct a <code>IrregularGrid</code> using <code>IrregularGrid(lower_bounds, upper_bounds, grid)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/grid_search.jl#L204-L216">source</a></section></article><h3 id="Performing-a-grid-search"><a class="docs-heading-anchor" href="#Performing-a-grid-search">Performing a grid search</a><a id="Performing-a-grid-search-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-a-grid-search" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.GridSearch" href="#ProfileLikelihood.GridSearch"><code>ProfileLikelihood.GridSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GridSearch{F,G}</code></pre><p>Struct for a <code>GridSearch</code>.</p><p><strong>Fields</strong></p><ul><li><code>f::F</code>: The function to optimise, of the form <code>f(x, p)</code>.</li><li><code>p::P</code>: The arguments <code>p</code> in the function <code>f</code>.</li><li><code>grid::G</code>: The grid, where <code>G&lt;:AbstractGrid</code>. See also <a href="#ProfileLikelihood.grid_search"><code>grid_search</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/grid_search.jl#L252-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProfileLikelihood.grid_search" href="#ProfileLikelihood.grid_search"><code>ProfileLikelihood.grid_search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">grid_search(prob; save_vals=Val(false), minimise:=Val(false), parallel=Val(false))</code></pre><p>Performs a grid search for the given grid search problem <code>prob</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prob::GridSearch{F, G}</code>: The grid search problem.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>save_vals:=Val(false)</code>: Whether to return a array with the function values. </li><li><code>minimise:=Val(false)</code>: Whether to minimise or to maximise the function.</li><li><code>parallel:=Val(false)</code>: Whether to run the grid search with multithreading.</li></ul><p><strong>Outputs</strong></p><ul><li><code>f_opt</code>: The optimal objective value. </li><li><code>x_argopt</code>: The parameter that gave <code>f_opt</code>.</li><li><code>f_res</code>: If <code>save_vals==Val(true)</code>, then this is the array of function values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/grid_search.jl#L283-L300">source</a></section><section><div><pre><code class="language-julia hljs">grid_search(f, grid::AbstractGrid; save_vals=Val(false), minimise=Val(false), parallel=Val(false))</code></pre><p>For a given <code>grid</code> and function <code>f</code>, performs a grid search. </p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function to optimise. </li><li><code>grid::AbstractGrid</code>: The grid to use for optimising. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>save_vals=Val(false)</code>: Whether to return a array with the function values. </li><li><code>minimise=Val(false)</code>: Whether to minimise or to maximise the function.</li><li><code>parallel=Val(false)</code>: Whether to run the grid search with multithreading.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/grid_search.jl#L329-L342">source</a></section><section><div><pre><code class="language-julia hljs">grid_search(prob::LikelihoodProblem, grid::AbstractGrid, parallel=Val(false); save_vals=Val(false))</code></pre><p>Given a <code>grid</code> and a likelihood problem <code>prob</code>, maximises it over the grid using a grid search. If  <code>save_vals==Val(true)</code>, then the likelihood function values at each gridpoint are returned. Set  <code>parallel=Val(true)</code> if you want multithreading.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/42d6403e52c5b3a72c50e0dfe8ba5038407ee41f/src/grid_search.jl#L345-L351">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interface</a><a class="docs-footer-nextpage" href="../regression/">Example I: Multiple linear regression »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 5 December 2023 12:07">Tuesday 5 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
