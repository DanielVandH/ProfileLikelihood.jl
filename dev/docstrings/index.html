<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ProfileLikelihood.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ProfileLikelihood.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li class="is-active"><a class="tocitem" href>Docstrings</a><ul class="internal"><li><a class="tocitem" href="#LikelihoodProblem"><span>LikelihoodProblem</span></a></li><li><a class="tocitem" href="#LikelihoodSolution"><span>LikelihoodSolution</span></a></li><li><a class="tocitem" href="#ProfileLikelihoodSolution"><span>ProfileLikelihoodSolution</span></a></li><li><a class="tocitem" href="#Prediction-intervals"><span>Prediction intervals</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#GridSearch"><span>GridSearch</span></a></li></ul></li><li><a class="tocitem" href="../regression/">Example I: Multiple linear regression</a></li><li><a class="tocitem" href="../logistic/">Example II: Logistic ordinary differential equation</a></li><li><a class="tocitem" href="../exponential/">Example III: Linear exponential ODE and grid searching</a></li><li><a class="tocitem" href="../heat/">Example IV: Diffusion equation on a square plate</a></li><li><a class="tocitem" href="../math/">Mathematical and Implementation Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/main/docs/src/docstrings.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h1><p>Here we give some of the main docstrings. </p><h2 id="LikelihoodProblem"><a class="docs-heading-anchor" href="#LikelihoodProblem">LikelihoodProblem</a><a id="LikelihoodProblem-1"></a><a class="docs-heading-anchor-permalink" href="#LikelihoodProblem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.AbstractLikelihoodProblem" href="#ProfileLikelihood.AbstractLikelihoodProblem"><code>ProfileLikelihood.AbstractLikelihoodProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLikelihoodProblem{N, L}</code></pre><p>Abstract type of a likelihood problem, where <code>N</code> is the number of parameters and  <code>L</code> is the type of the likelihood function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/abstract_type_definitions.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.LikelihoodProblem" href="#ProfileLikelihood.LikelihoodProblem"><code>ProfileLikelihood.LikelihoodProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LikelihoodProblem{N,P,D,L,Θ,S} &lt;: AbstractLikelihoodProblem</code></pre><p>Struct representing a likelihood problem. </p><p><strong>Fields</strong></p><ul><li><code>problem::P</code></li></ul><p>The associated <code>OptimizationProblem</code>.</p><ul><li><code>data::D</code></li></ul><p>The argument <code>p</code> used in the log-likelihood function. </p><ul><li><code>log_likelihood_function::L</code></li></ul><p>The log-likelihood function, taking the form <code>ℓ(θ, p)</code>.</p><ul><li><code>θ₀::Θ</code></li></ul><p>Initial estimates for the MLE <code>θ</code>.</p><ul><li><code>syms::S</code></li></ul><p>Variable names for the parameters.</p><p>The extra parameter <code>N</code> is the number of parameters.</p><p><strong>Constructors</strong></p><p><strong>Standard</strong></p><pre><code class="nohighlight hljs">LikelihoodProblem(loglik::Function, θ₀;
    syms=eachindex(θ₀), data=SciMLBase.NullParameters(),
    f_kwargs=nothing, prob_kwargs=nothing)</code></pre><p>Constructor for the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>loglik::Function</code>: The log-likelihood function, taking the form <code>ℓ(θ, p)</code>.</li><li><code>θ₀</code>: The estimates estimates for the MLEs.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>syms=eachindex(θ₀)</code>: Names for each parameter. </li><li><code>data=SciMLBase.NullParameters()</code>: The parameter <code>p</code> in the log-likelihood function. </li><li><code>f_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationFunction</code>.</li><li><code>prob_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationProblem</code>.</li></ul><p><strong>Outputs</strong></p><p>Returns the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> problem object.</p><p><strong>With arguments for a differential equation problem</strong></p><pre><code class="nohighlight hljs">LikelihoodProblem(loglik::Function, θ₀,
    ode_function, u₀, tspan;
    syms=eachindex(θ₀), data=SciMLBase.NullParameters(),
    ode_parameters=SciMLBase.NullParameters(), ode_alg,
    ode_kwargs=nothing, f_kwargs=nothing, prob_kwargs=nothing)</code></pre><p>Constructor for the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> for a differential equation problem.</p><p><strong>Arguments</strong></p><ul><li><code>loglik::Function</code>: The log-likelihood function, taking the form <code>ℓ(θ, p, integrator)</code>.</li><li><code>θ₀</code>: The estimates estimates for the MLEs.</li><li><code>ode_function</code>: The function <code>f(du, u, p, t)</code> or <code>f(u, p, t)</code> for the differential equation.</li><li><code>u₀</code>: The initial condition for the differential equation. </li><li><code>tspan</code>: The time-span to solve the differential equaton over. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>syms=eachindex(θ₀)</code>: Names for each parameter. </li><li><code>data=SciMLBase.NullParameters()</code>: The parameter <code>p</code> in the log-likelihood function. </li><li><code>ode_parameters=SciMLBase.NullParameters()</code>: The parameter <code>p</code> in <code>ode_function</code>.</li><li><code>ode_alg</code>: The algorithm used for solving the differential equatios.</li><li><code>ode_kwargs=nothing</code>: Extra keyword arguments, passed as a <code>NamedTuple</code>, to pass into the integrator; see <code>construct_integrator</code>.</li><li><code>f_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationFunction</code>.</li><li><code>prob_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationProblem</code>.</li></ul><p><strong>Outputs</strong></p><p>Returns the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> problem object.</p><p><strong>With an integrator</strong></p><pre><code class="nohighlight hljs">LikelihoodProblem(loglik::Function, θ₀, integrator;
    syms=eachindex(θ₀), data=SciMLBase.NullParameters(),
    f_kwargs=nothing, prob_kwargs=nothing)</code></pre><p>Constructor for the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> for a differential equation problem  with associated <code>integrator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>loglik::Function</code>: The log-likelihood function, taking the form <code>ℓ(θ, p, integrator)</code>.</li><li><code>θ₀</code>: The estimates estimates for the MLEs.</li><li><code>integrator</code>: The integrator for the differential equation problem. See also <code>construct_integrator</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>syms=eachindex(θ₀)</code>: Names for each parameter. </li><li><code>data=SciMLBase.NullParameters()</code>: The parameter <code>p</code> in the log-likelihood function. </li><li><code>f_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationFunction</code>.</li><li><code>prob_kwargs=nothing</code>: Keyword arguments, passed as a <code>NamedTuple</code>, for the <code>OptimizationProblem</code>.</li></ul><p><strong>Outputs</strong></p><p>Returns the <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a> problem object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/likelihood_problem.jl#L9-L106">source</a></section></article><h2 id="LikelihoodSolution"><a class="docs-heading-anchor" href="#LikelihoodSolution">LikelihoodSolution</a><a id="LikelihoodSolution-1"></a><a class="docs-heading-anchor-permalink" href="#LikelihoodSolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.AbstractLikelihoodSolution" href="#ProfileLikelihood.AbstractLikelihoodSolution"><code>ProfileLikelihood.AbstractLikelihoodSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLikelihoodSolution{N, P}</code></pre><p>Type representing the solution to a likelihood problem, where <code>N</code> is the  number of parameters and <code>P</code> is the type of the likelihood problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/abstract_type_definitions.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.LikelihoodSolution" href="#ProfileLikelihood.LikelihoodSolution"><code>ProfileLikelihood.LikelihoodSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LikelihoodSolution{Θ,P,M,R,A} &lt;: AbstractLikelihoodSolution</code></pre><p>Struct for a solution to a <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>mle::Θ</code>: The MLEs.</li><li><code>problem::P</code>: The <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</li><li><code>optimiser::A</code>: The algorithm used for solving the optimisation problem. </li><li><code>maximum::M</code>: The maximum likelihood. </li><li><code>retcode::R</code>: The <code>SciMLBase.ReturnCode</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">LikelihoodSolution(sol::SciMLBase.OptimizationSolution, prob::AbstractLikelihoodProblem; alg=sol.alg)</code></pre><p>Constructs the likelihood solution from a solution to an <code>OptimizationProblem</code> with a given <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/likelihood_solution.jl#L8-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.mle" href="#ProfileLikelihood.mle"><code>ProfileLikelihood.mle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mle(prob::LikelihoodProblem, alg, args...; kwargs...)
mle(prob::LikelihoodProblem, alg::Tuple, args...; kwargs...)</code></pre><p>Given the likelihood problem <code>prob</code> and an optimiser <code>alg</code>, finds the MLEs and returns a  <a href="#ProfileLikelihood.LikelihoodSolution"><code>LikelihoodSolution</code></a> object. Extra arguments and keyword arguments for <code>solve</code> can be passed  through <code>args...</code> and <code>kwargs...</code>.</p><p>If <code>alg</code> is a <code>Tuple</code>, then the problem is re-optimised after each algorithm with the next element in alg,  starting from <code>alg[1]</code>, with initial estimate coming from the solution with the  previous algorithm (starting with <code>get_initial_estimate(prob)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/mle.jl#L1-L12">source</a></section></article><h2 id="ProfileLikelihoodSolution"><a class="docs-heading-anchor" href="#ProfileLikelihoodSolution">ProfileLikelihoodSolution</a><a id="ProfileLikelihoodSolution-1"></a><a class="docs-heading-anchor-permalink" href="#ProfileLikelihoodSolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.ProfileLikelihoodSolution" href="#ProfileLikelihood.ProfileLikelihoodSolution"><code>ProfileLikelihood.ProfileLikelihoodSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProfileLikelihoodSolution{I,V,LP,LS,Spl,CT,CF,OM}</code></pre><p>Struct for the normalised profile log-likelihood. See <a href="#ProfileLikelihood.profile"><code>profile</code></a> for a constructor.</p><p><strong>Fields</strong></p><ul><li><code>θ::Dict{I, V}</code>: This is a dictionary such that <code>θ[i]</code> gives the parameter values used for the normalised profile log-likelihood of the <code>i</code>th variable.</li><li><code>profile::Dict{I, V}</code>: This is a dictionary such that <code>profile[i]</code> gives the values of the normalised profile log-likelihood function at the corresponding values in <code>θ[i]</code>.</li><li><code>prob::LP</code>: The original <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</li><li><code>mle::LS</code>: The solution to the full problem.</li><li><code>spline::Dict{I, Spl}</code>: This is a dictionary such that <code>spline[i]</code> is a spline through the data <code>(θ[i], profile[i])</code>. This spline can be evaluated at a point <code>ψ</code> for the <code>i</code>th variable by calling an instance of the struct with arguments <code>(ψ, i)</code>. See also <code>spline_profile</code>.</li><li><code>confidence_intervals::Dict{I,ConfidenceInterval{CT,CF}}</code>: This is a dictonary such that <code>confidence_intervals[i]</code> is a confidence interval for the <code>i</code>th parameter.</li><li><code>other_mles::OM</code>: This is a dictionary such that <code>other_mles[i]</code> gives the vector for the MLEs of the other parameters not being profiled, for each datum.</li></ul><p><strong>Spline evaluation</strong></p><p>This struct is callable. We define the method </p><pre><code class="nohighlight hljs">(prof::ProfileLikelihoodSolution)(θ, i)</code></pre><p>that evaluates the spline through the <code>i</code>th profile at the point <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/profile_likelihood_solution.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.ConfidenceInterval" href="#ProfileLikelihood.ConfidenceInterval"><code>ProfileLikelihood.ConfidenceInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConfidenceInterval{T, F}</code></pre><p>Struct representing a confidence interval. </p><p><strong>Fields</strong></p><ul><li><code>lower::T</code>: The lower bound of the confidence interval. </li><li><code>upper::T</code>: The upper bound of the confidence interval. </li><li><code>level::F</code>: The level of the confidence interval.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/confidence_interval.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.profile" href="#ProfileLikelihood.profile"><code>ProfileLikelihood.profile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">profile(prob::LikelihoodProblem, sol::LikelihoodSolution, n=1:number_of_parameters(prob);
    alg=get_optimiser(sol),
    conf_level::F=0.95,
    confidence_interval_method=:spline,
    threshold=get_chisq_threshold(conf_level),
    resolution=200,
    param_ranges=construct_profile_ranges(sol, get_lower_bounds(prob), get_upper_bounds(prob), resolution),
    min_steps=10,
    normalise::Bool=true,
    spline_alg=FritschCarlsonMonotonicInterpolation,
    extrap=Line,
    parallel=false,
    next_initial_estimate_method = :prev,
    kwargs...)</code></pre><p>Computes profile likelihoods for the parameters from a likelihood problem <code>prob</code> with MLEs <code>sol</code>.</p><p>See also <a href="#ProfileLikelihood.replace_profile!"><code>replace_profile!</code></a> which allows you to re-profile a parameter in case you are not satisfied with  the results. For plotting, see the <code>plot_profiles</code> function (requires that you have loaded CairoMakie.jl and  LaTeXStrings.jl to access the function).</p><p><strong>Arguments</strong></p><ul><li><code>prob::LikelihoodProblem</code>: The <a href="#ProfileLikelihood.LikelihoodProblem"><code>LikelihoodProblem</code></a>.</li><li><code>sol::LikelihoodSolution</code>: The <a href="#ProfileLikelihood.LikelihoodSolution"><code>LikelihoodSolution</code></a>. See also <a href="#ProfileLikelihood.mle"><code>mle</code></a>.</li><li><code>n=1:number_of_parameters(prob)</code>: The parameter indices to compute the profile likelihoods for.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>alg=get_optimiser(sol)</code>: The optimiser to use for solving each optimisation problem. </li><li><code>conf_level::F=0.95</code>: The level to use for the <a href="#ProfileLikelihood.ConfidenceInterval"><code>ConfidenceInterval</code></a>s.</li><li><code>confidence_interval_method=:spline</code>: The method to use for computing the confidence intervals. See also <code>get_confidence_intervals!</code>. The default <code>:spline</code> uses rootfinding on the spline through the data, defining a continuous function, while the alternative <code>:extrema</code> simply takes the extrema of the values that exceed the threshold.</li><li><code>threshold=get_chisq_threshold(conf_level)</code>: The threshold to use for defining the confidence intervals. </li><li><code>resolution=200</code>: The number of points to use for evaluating the profile likelihood in each direction starting from the MLE (giving a total of 400 points).</li><li><code>param_ranges=construct_profile_ranges(sol, get_lower_bounds(prob), get_upper_bounds(prob), resolution)</code>: The ranges to use for each parameter.</li><li><code>min_steps=10</code>: The minimum number of steps to allow for the profile in each direction. If fewer than this number of steps are used before reaching threshold, then the algorithm restarts and computes the profile likelihood a number <code>min_steps</code> of points in that direction. </li><li><code>normalise::Bool=true</code>: Whether to optimise the normalised profile log-likelihood or not. </li><li><code>spline_alg=FritschCarlsonMonotonicInterpolation</code>: The interpolation algorithm to use for computing a spline from the profile data. See Interpolations.jl. </li><li><code>extrap=Line</code>: The extrapolation algorithm to use for computing a spline from the profile data. See Interpolations.jl.</li><li><code>parallel=false</code>: Whether to use multithreading. If <code>true</code>, will use multithreading so that multiple parameters are profiled at once, and the steps to the left and right are done at the same time. </li><li><code>next_initial_estimate_method = :prev</code>: Method for selecting the next initial estimate when stepping forward when profiling. <code>:prev</code> simply uses the previous solution, but you can also use <code>:interp</code> to use linear interpolation. See also <a href="#ProfileLikelihood.set_next_initial_estimate!"><code>set_next_initial_estimate!</code></a>.</li><li><code>kwargs...</code>: Extra keyword arguments to pass into <code>solve</code> for solving the <code>OptimizationProblem</code>. See also the docs from Optimization.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/profile_likelihood.jl#L3-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.replace_profile!" href="#ProfileLikelihood.replace_profile!"><code>ProfileLikelihood.replace_profile!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replace_profile!(prof::ProfileLikelihoodSolution, n);
    alg=get_optimiser(prof.likelihood_solution),
    conf_level::F=0.95,
    confidence_interval_method=:spline,
    threshold=get_chisq_threshold(conf_level),
    resolution=200,
    param_ranges=construct_profile_ranges(prof.likelihood_solution, get_lower_bounds(prof.likelihood_problem), get_upper_bounds(prof.likelihood_problem), resolution),
    min_steps=10,
    normalise::Bool=true,
    spline_alg=FritschCarlsonMonotonicInterpolation,
    extrap=Line,
    parallel=false,
    next_initial_estimate_method=:prev,
    kwargs...) where {F}</code></pre><p>Given an existing <code>prof::ProfileLikelihoodSolution</code>, replaces the profile results for the parameters in <code>n</code>. The keyword  arguments are the same as for <a href="#ProfileLikelihood.profile"><code>profile</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/profile_likelihood.jl#L91-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.set_next_initial_estimate!" href="#ProfileLikelihood.set_next_initial_estimate!"><code>ProfileLikelihood.set_next_initial_estimate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_next_initial_estimate!(sub_cache, param_vals, other_mles, prob, θₙ; next_initial_estimate_method=:prev)</code></pre><p>Method for selecting the next initial estimate for the optimisers. <code>sub_cache</code> is the cache vector for placing  the initial estimate into, <code>param_vals</code> is the current list of parameter values for the interest parameter,  and <code>other_mles</code> is the corresponding list of previous optimisers. <code>prob</code> is the <code>OptimizationProblem</code>. The value  <code>θₙ</code> is the next value of the interest parameter.</p><p>The available methods are: </p><ul><li><code>next_initial_estimate_method = :prev</code>: If this is selected, simply use <code>other_mles[end]</code>, i.e. the previous optimiser. </li><li><code>next_initial_estimate_method = :interp</code>: If this is selected, the next optimiser is determined via linear interpolation using the data <code>(param_vals[end-1], other_mles[end-1]), (param_vals[end], other_mles[end])</code>. If the new approximation is outside of the parameter bounds, falls back to <code>next_initial_estimate_method = :prev</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/profile_likelihood.jl#L273-L285">source</a></section></article><h2 id="Prediction-intervals"><a class="docs-heading-anchor" href="#Prediction-intervals">Prediction intervals</a><a id="Prediction-intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction-intervals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.get_prediction_intervals" href="#ProfileLikelihood.get_prediction_intervals"><code>ProfileLikelihood.get_prediction_intervals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_prediction_intervals(q, prof::ProfileLikelihoodSolution, data;
    q_type=get_q_type(q, prof, data), resolution=250)</code></pre><p>Given a prediction of the form <code>q(θ, data)</code>, where <code>θ</code> has the same size as the <code>θ</code> used in  the profile likelihood solution <code>prof</code>, and <code>data</code> is the argument <code>data</code>, computes the prediction  intervals for <code>q</code> (possibly at each point if it outputs a vector) using the confidence intervals from <code>prof</code>. You can set the output of the prediction function using <code>q_type</code>, and the grid resolution when evaluating the prediction  function for each parameter via <code>resolution</code>.</p><p>Two results are produced:</p><ul><li><code>parameterwise_cis</code>: This is a <code>Dict</code> mapping parameter indices to a a vector of confidence intervals from each output of <code>q</code> for the corresponding parameter. </li><li><code>union_cis</code>: This gives the union of the intervals from <code>parameterwise_cis</code> (just taking the extrema over each interal) at each output of <code>q</code>.</li></ul><p>We also return <code>all_curves</code>, a <code>Dict</code> mapping parameter indices to the vector of <code>q</code> values for each parameter,  and these parameter ranges are given in <code>param_ranges</code>. So, the final output looks like:</p><p><code>(parameterwise_cis, union_cis, all_curves, param_ranges)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/prediction_intervals.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.eval_prediction_function" href="#ProfileLikelihood.eval_prediction_function"><code>ProfileLikelihood.eval_prediction_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_prediction_function(q, prof::ProfileLikelihoodSolution, data;
    resolution=250,
    param_ranges=Dict(profiled_parameters(prof) .=&gt; [LinRange(get_confidence_intervals(prof[i])..., resolution) for i in profiled_parameters(prof)]),
    q_type=get_q_type(q, prof, data))</code></pre><p>Given a prediction of the form <code>q(θ, data)</code>, where <code>θ</code> has the same size as the <code>θ</code> used in  the profile likelihood solution <code>prof</code>, and <code>data</code> is the argument <code>data</code>, and for each parameter index <code>i</code>: Evaluates <code>q((ψ, ωˢ(ψ)), data)</code>, where <code>ψ</code> ranges over <code>param_ranges[i]</code> and <code>ωˢ(ψ)</code> are the parameter values  that lead to the value of the profile likelihood function where <code>θ[i] = ψ</code>. </p><p>You can set the type of the output from the prediction function <code>q</code> using <code>q_type</code>.</p><p>The output is a <code>Dict</code> mapping the profiled parameter indices (from <code>profiled_parameters</code>) to the outputs from <code>q</code> at each  corresponding parameter in <code>param_ranges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/prediction_intervals.jl#L61-L76">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.plot_profiles" href="#ProfileLikelihood.plot_profiles"><code>ProfileLikelihood.plot_profiles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_profiles(prof::ProfileLikelihoodSolution, vars = profiled_parameters(prof); 
    ncol=nothing, 
    nrow=nothing,
    true_vals=Dict(vars .=&gt; nothing), 
    spline=true, 
    show_mles=true, 
    shade_ci=true, 
    fig_kwargs=nothing, 
    axis_kwargs=nothing,
    latex_names = Dict(vars .=&gt; [LaTeXStrings.L&quot;	heta_{i}&quot; for i in SciMLBase.sym_to_index.(vars, Ref(prof))]))</code></pre><p>Plot results from a profile likelihood solution <code>prof</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prof::ProfileLikelihoodSolution</code>: The profile likelihood solution from <a href="#ProfileLikelihood.profile"><code>profile</code></a>.</li><li><code>vars = profiled_parameters(prof)</code>: The parameters to plot.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ncol=nothing</code>: The number of columns to use. If <code>nothing</code>, chosen automatically via <code>choose_grid_layout</code>.</li><li><code>nrow=nothing</code>: The number of rows to use. If <code>nothing</code>, chosen automatically via <code>choose_grid_layout</code></li><li><code>true_vals=Dict(vars .=&gt; nothing)</code>: A dictionary mapping parameter indices to their true values, if they exist. If <code>nothing</code>, nothing is plotted, otherwise a black line is plotted at the true value for the profile. </li><li><code>spline=true</code>: Whether the curve plotted should come from a spline through the results, or if the data itself should be plotted. </li><li><code>show_mles=true</code>: Whether to put a red line at the MLEs. </li><li><code>shade_ci=true</code>: Whether to shade the area under the profile between the confidence interval.</li><li><code>fig_kwargs=nothing</code>: Extra keyword arguments for <code>Figure</code> (see the Makie docs).</li><li><code>axis_kwargs=nothing</code>: Extra keyword arguments for <code>Axis</code> (see the Makie docs).</li><li><code>latex_names = Dict(vars .=&gt; [LaTeXStrings.L&quot;	heta_{i}&quot; for i in SciMLBase.sym_to_index.(vars, Ref(prof))]))</code>: LaTeX names to use for the parameters. Defaults to <code>θᵢ</code>, where <code>i</code> is the index of the parameter. </li></ul><p><strong>Output</strong></p><p>The <code>Figure()</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/plotting.jl#L68-L99">source</a></section></article><h2 id="GridSearch"><a class="docs-heading-anchor" href="#GridSearch">GridSearch</a><a id="GridSearch-1"></a><a class="docs-heading-anchor-permalink" href="#GridSearch" title="Permalink"></a></h2><h3 id="Grid-definitions"><a class="docs-heading-anchor" href="#Grid-definitions">Grid definitions</a><a id="Grid-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-definitions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.AbstractGrid" href="#ProfileLikelihood.AbstractGrid"><code>ProfileLikelihood.AbstractGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractGrid{N,B,T}</code></pre><p>Type representing a grid, where <code>N</code> is the number of parameters, <code>B</code> is the type for the  bounds, and <code>T</code> is the number type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/abstract_type_definitions.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.RegularGrid" href="#ProfileLikelihood.RegularGrid"><code>ProfileLikelihood.RegularGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RegularGrid{N,B,R,S,T} &lt;: AbstractGrid{N,B,T}</code></pre><p>Struct for a grid in which each parameter is regularly spaced. </p><p><strong>Fields</strong></p><ul><li><code>lower_bounds::B</code>: Lower bounds for each parameter. </li><li><code>upper_bounds::B</code>: Upper bounds for each parameter. </li><li><code>resolution::R</code>: Number of grid points for each parameter. If <code>R &lt;: Number</code>, then the same number of grid points is used for each parameter. </li><li><code>step_sizes::S</code>: Grid spacing for each parameter. </li></ul><p><strong>Constructor</strong></p><p>You can construct a <code>RegularGrid</code> using <code>RegularGrid(lower_bounds, upper_bounds, resolution)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/grid_search.jl#L4-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.IrregularGrid" href="#ProfileLikelihood.IrregularGrid"><code>ProfileLikelihood.IrregularGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IrregularGrid{N,B,R,S,T} &lt;: AbstractGrid{N,B,T}</code></pre><p>Struct for an irregular grid of parameters.</p><p><strong>Fields</strong></p><ul><li><code>lower_bounds::B</code>: Lower bounds for each parameter. </li><li><code>upper_bounds::B</code>: Upper bounds for each parameter. </li><li><code>grid::G</code>: The set of parameter values, e.g. a matrix where each column is the parameter vector.</li></ul><p><strong>Constructor</strong></p><p>You can construct a <code>IrregularGrid</code> using <code>IrregularGrid(lower_bounds, upper_bounds, grid)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/grid_search.jl#L79-L91">source</a></section></article><h3 id="Performing-a-grid-search"><a class="docs-heading-anchor" href="#Performing-a-grid-search">Performing a grid search</a><a id="Performing-a-grid-search-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-a-grid-search" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.GridSearch" href="#ProfileLikelihood.GridSearch"><code>ProfileLikelihood.GridSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GridSearch{F,G}</code></pre><p>Struct for a <code>GridSearch</code>.</p><p><strong>Fields</strong></p><ul><li><code>f::F</code>: The function to optimise, of the form <code>f(x, p)</code>.</li><li><code>p::P</code>: The arguments <code>p</code> in the function <code>f</code>.</li><li><code>grid::G</code>: The grid, where <code>G&lt;:AbstractGrid</code>. See also <a href="#ProfileLikelihood.grid_search"><code>grid_search</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/grid_search.jl#L127-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProfileLikelihood.grid_search" href="#ProfileLikelihood.grid_search"><code>ProfileLikelihood.grid_search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">grid_search(prob; save_vals=Val(false), minimise:=Val(false), parallel=Val(false))</code></pre><p>Performs a grid search for the given grid search problem <code>prob</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prob::GridSearch{F, G}</code>: The grid search problem.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>save_vals:=Val(false)</code>: Whether to return a array with the function values. </li><li><code>minimise:=Val(false)</code>: Whether to minimise or to maximise the function.</li><li><code>parallel:=Val(false)</code>: Whether to run the grid search with multithreading.</li></ul><p><strong>Outputs</strong></p><ul><li><code>f_opt</code>: The optimal objective value. </li><li><code>x_argopt</code>: The parameter that gave <code>f_opt</code>.</li><li><code>f_res</code>: If <code>save_vals==Val(true)</code>, then this is the array of function values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/grid_search.jl#L158-L175">source</a></section><section><div><pre><code class="nohighlight hljs">grid_search(f, grid::AbstractGrid; save_vals=Val(false), minimise=Val(false), parallel=Val(false))</code></pre><p>For a given <code>grid</code> and function <code>f</code>, performs a grid search. </p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function to optimise. </li><li><code>grid::AbstractGrid</code>: The grid to use for optimising. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>save_vals=Val(false)</code>: Whether to return a array with the function values. </li><li><code>minimise=Val(false)</code>: Whether to minimise or to maximise the function.</li><li><code>parallel=Val(false)</code>: Whether to run the grid search with multithreading.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/grid_search.jl#L204-L217">source</a></section><section><div><pre><code class="nohighlight hljs">grid_search(prob::LikelihoodProblem, grid::AbstractGrid, parallel=Val(false); save_vals=Val(false))</code></pre><p>Given a <code>grid</code> and a likelihood problem <code>prob</code>, maximises it over the grid using a grid search. If  <code>save_vals==Val(true)</code>, then the likelihood function values at each gridpoint are returned. Set  <code>parallel=Val(true)</code> if you want multithreading.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/e0b3218cfae7adc34e03812f7daaa720bd0fafad/src/grid_search.jl#L220-L226">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interface</a><a class="docs-footer-nextpage" href="../regression/">Example I: Multiple linear regression »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 21 December 2022 18:32">Wednesday 21 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
