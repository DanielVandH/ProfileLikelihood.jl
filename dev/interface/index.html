<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface · ProfileLikelihood.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ProfileLikelihood.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Interface</a><ul class="internal"><li><a class="tocitem" href="#LikelihoodProblem:-Defining-the-likelihood-problem"><span>LikelihoodProblem: Defining the likelihood problem</span></a></li><li><a class="tocitem" href="#LikelihoodSolution:-Obtaining-an-MLE"><span>LikelihoodSolution: Obtaining an MLE</span></a></li><li><a class="tocitem" href="#ProfileLikelihoodsolution:-Profiling-the-parameters"><span>ProfileLikelihoodsolution: Profiling the parameters</span></a></li><li><a class="tocitem" href="#Propagating-uncertainty:-Prediction-intervals"><span>Propagating uncertainty: Prediction intervals</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#GridSearch"><span>GridSearch</span></a></li></ul></li><li><a class="tocitem" href="../docstrings/">Docstrings</a></li><li><a class="tocitem" href="../regression/">Example I: Multiple linear regression</a></li><li><a class="tocitem" href="../logistic/">Example II: Logistic ordinary differential equation</a></li><li><a class="tocitem" href="../exponential/">Example III: Linear exponential ODE and grid searching</a></li><li><a class="tocitem" href="../heat/">Example IV: Diffusion equation on a square plate</a></li><li><a class="tocitem" href="../math/">Mathematical and Implementation Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/ProfileLikelihood.jl/blob/main/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h1><p>The interface for defining a likelihood problem builds on top of <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a>. Below we list the three main structs that we use, with <code>LikelihoodProblem</code> the most important one and the only one that needs to be directly defined. Examples of how we use these structs are given later, and much extra functionality is given in the tests. Complete docstrings are given in the sidebar.</p><h2 id="LikelihoodProblem:-Defining-the-likelihood-problem"><a class="docs-heading-anchor" href="#LikelihoodProblem:-Defining-the-likelihood-problem">LikelihoodProblem: Defining the likelihood problem</a><a id="LikelihoodProblem:-Defining-the-likelihood-problem-1"></a><a class="docs-heading-anchor-permalink" href="#LikelihoodProblem:-Defining-the-likelihood-problem" title="Permalink"></a></h2><p>The <code>LikelihoodProblem</code> is the definition of a likelihood function, and provides the following constructor:</p><pre><code class="language-julia hljs">LikelihoodProblem(loglik::Function, θ₀;
    syms=eachindex(θ₀), data=SciMLBase.NullParameters(),
    f_kwargs=nothing, prob_kwargs=nothing)</code></pre><p>Here, <code>loglik</code> is a function for the log-likelihood, taking the form <code>ℓ(θ, p)</code>. The second argument, <code>θ₀</code>, is the initial estimate for the parameter values. You can provide symbolic names for the parameters via <code>syms</code>, so that e.g. <code>prob[:α]</code> (where <code>prob</code> is a <code>LikelihoodProblem</code> with <code>:α ∈ syms</code>) returns the initial estimate for <code>:α</code>. The argument <code>p</code> in the likelihood function can be used to pass data or other parameters into the argument, and the keyword argument <code>data</code> can be used for this. Lastly, <code>f_kwargs</code> and <code>prob_kwargs</code> are additional keyword arguments for the <code>OptimizationFunction</code> and <code>OptimizationProblem</code>, respectively; see the <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a> documentation for more detail here.</p><p>We also provide a simple interface for defining a log-likelihood that requires the solution of a differential equation:</p><pre><code class="language-julia hljs">LikelihoodProblem(loglik::Function, θ₀,
    ode_function, u₀, tspan;
    syms=eachindex(θ₀), data=SciMLBase.NullParameters(),
    ode_parameters=SciMLBase.NullParameters(), ode_alg,
    ode_kwargs=nothing, f_kwargs=nothing, prob_kwargs=nothing)</code></pre><p>Importantly, <code>loglik</code> in this case is now a function of the form <code>ℓ(θ, p, integrator)</code>, where <code>integrator</code> is the same integrator as in the integrator interface from DifferentialEquations.jl; see the documentation at DifferentialEquations.jl for more detail on using the integrator. Furthermore, <code>ode_function</code> is the function for the ODE, <code>u₀</code> its initial condition, and <code>tspan</code> its time span. Additionally, the parameters for the <code>ode_function</code> (e.g. the <code>p</code> in <code>ode_function(du, u, p, t)</code> or <code>ode_function(u, p, t)</code>) can be passed using the keyword argument <code>ode_parameters</code>. The algorithm used to solve the differential equation is passed with <code>ode_alg</code>, and lastly any additional keyword arguments for solving the problem are to be passed through <code>ode_kwargs</code>. </p><p>The full docstrings for the three methods available are given in the sidebar.</p><h2 id="LikelihoodSolution:-Obtaining-an-MLE"><a class="docs-heading-anchor" href="#LikelihoodSolution:-Obtaining-an-MLE">LikelihoodSolution: Obtaining an MLE</a><a id="LikelihoodSolution:-Obtaining-an-MLE-1"></a><a class="docs-heading-anchor-permalink" href="#LikelihoodSolution:-Obtaining-an-MLE" title="Permalink"></a></h2><p>The MLEs for a given <code>LikelihoodProblem</code> are found using the function <code>mle</code>, e.g. <code>mle(prob, Optim.LBFGS())</code> will optimise the likelihood function using the LBFGS algorithm from Optim.jl (see also <code>?mle</code>). This function returns a <code>LikelihoodSolution</code>, defined by:</p><pre><code class="language-julia hljs">struct LikelihoodSolution{N,Θ,P,M,R,A} &lt;: AbstractLikelihoodSolution{N,P}
    mle::Θ
    problem::P
    optimiser::A
    maximum::M
    retcode::R
end</code></pre><p>If <code>sol isa LikelihoodSolution</code>, then you can use the <code>syms</code> from your original problem to access a specific MLE, e.g. <code>sol[:α]</code> would return the MLE for the paramter <code>:α</code>.</p><p>If you want to use multiple optimisers, i.e. a sequence of optimisers <span>$(O_1, O_2, \ldots)$</span>, in which <span>$O_j$</span>&#39;s initial estimate starts from the solution from the optimiser <span>$O_{j-1}$</span>, you can also provide a <code>Tuple</code> into the algorithm argument, e.g. <code>mle(prob, (Optim.LBFGS(), NLopt.LN_NELDERMEAD))</code>.</p><p>The full docstring for <code>mle</code> is given in the docstring section in the sidebar, along with the docstring for <code>LikelihoodSolution</code>.</p><h2 id="ProfileLikelihoodsolution:-Profiling-the-parameters"><a class="docs-heading-anchor" href="#ProfileLikelihoodsolution:-Profiling-the-parameters">ProfileLikelihoodsolution: Profiling the parameters</a><a id="ProfileLikelihoodsolution:-Profiling-the-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#ProfileLikelihoodsolution:-Profiling-the-parameters" title="Permalink"></a></h2><p>The results for a profile likelihood, obtained from <code>profile(prob, sol)</code> (see also <code>?profile</code>), are stored in a <code>ProfileLikelihoodSolution</code> struct:</p><pre><code class="language-julia hljs">struct ProfileLikelihoodSolution{I,V,LP,LS,Spl,CT,CF,OM}
    parameter_values::Dict{I,V}
    profile_values::Dict{I,V}
    likelihood_problem::LP
    likelihood_solution::LS
    splines::Dict{I,Spl}
    confidence_intervals::Dict{I,ConfidenceInterval{CT,CF}}
    other_mles::OM
end</code></pre><p>Here, the parameter values used for each parameter are given in <code>parameter_values</code>, with parameter indices (or symbols) mapped to these values. Similarly, the values of the profile log-likelihood are stored in <code>profile_values</code>. We use a spline (see Interpolations.jl) to make the profile log-likelihood a continuous function, and these splines are given by <code>splines</code>. Next, the computed confidence intervals are given in <code>confidence_intervals</code>, with a confidence interval represented by a <code>ConfidenceInterval</code> struct. Lastly, since computing the profile log-likelihood function requires an optimisation problem with one variable fixed and the others free, we obtain for each profile log-likelihood value a set of optimised parameters – these parameters are given in <code>other_mles</code>.</p><p>If <code>prof</code> is a <code>ProfileLikelihoodSolution</code>, then you can also call it as e.g. <code>prof(0.5, 1)</code> to evaluate the profile log-likelihood function of the first parameter at the point <code>0.5</code>. Alternatively, <code>prof(0.7, :α)</code> does the same but for the parameter <code>:α</code> at the point <code>0.7</code>. You can also index <code>prof</code> at a specific index (or symbol) to see the results only for that parameter, e.g. <code>prof[1]</code> or <code>prof[:α]</code>; this returns a <code>ProfileLikelihoodSolutionView</code>.</p><p>The full docstring for <code>profile</code> and related functions are given in the sidebar.</p><h2 id="Propagating-uncertainty:-Prediction-intervals"><a class="docs-heading-anchor" href="#Propagating-uncertainty:-Prediction-intervals">Propagating uncertainty: Prediction intervals</a><a id="Propagating-uncertainty:-Prediction-intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Propagating-uncertainty:-Prediction-intervals" title="Permalink"></a></h2><p>The confidence intervals obtained from profiling can be used to obtain approximate prediction intervals via <em>profile-wise profile likelihoods</em>, as defined e.g. in <a href="https://doi.org/10.1101/2022.12.14.520367">Simpson and Maclaren (2022)</a>, for a prediction function <span>$\boldsymbol q(\boldsymbol\theta)$</span>. These intervals can be based on varying a single parameter, or by taking the union of individual prediction intervals. The main function for this is <code>get_prediction_intervals</code>. Rather than explain in full detail here, please refer to the second example below (the logistic ODE example), where we reproduce the first case study of <a href="https://doi.org/10.1101/2022.12.14.520367">Simpson and Maclaren (2022)</a>.</p><p>The interface we use in <code>get_prediction_intervals</code> is not too refined currently, and is most subject to change. It works for now, but I will probably make it be more generally about predictions of vector quantities, assuming a function that returns a tuple of quantities, rather than having to deal with the case of scalar vs vector vs whatever else quantities. Ideally the interface should more easily support multithreading, and the code is not the cleanest to read either. Suggestions for this interface are especially welcome.</p><p>The full docstring for <code>get_prediction_intervals</code> is given in the sidebar.</p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>We provide a function <code>plot_profiles</code> that can be useful for plotting profile likelihoods. It requires that you have done </p><pre><code class="language-julia hljs">using CairoMakie
using LaTeXString </code></pre><p>(else the function does not exist, thanks to Requires.jl). A full description of this function is given in the corresponding docstring in the sidebar.</p><h2 id="GridSearch"><a class="docs-heading-anchor" href="#GridSearch">GridSearch</a><a id="GridSearch-1"></a><a class="docs-heading-anchor-permalink" href="#GridSearch" title="Permalink"></a></h2><p>it can sometimes be useful to evaluate the likelihood function over many points prior to optimising it, e.g. to find a good initial estimate or to just obtain data at many points for the purpose of visualisation. We provide functions for this, based on either a <code>RegularGrid</code> or an <code>IrregularGrid</code>.</p><p>A <code>RegularGrid</code> is a grid in which the grid for each parameter is uniformly spaced, so that the values for all parameter values to try fall on a lattice. An <code>IrregularGrid</code> allows for the parameters to take on whatever values you want, with the requirement that the parameter values to evaluate at are provided as a matrix with each column a different parameter set.</p><p>The function <code>grid_search</code>, after having defined a grid, can then be used for performing the grid search. The main method of interest is:</p><pre><code class="language-julia hljs">grid_search(prob::LikelihoodProblem, grid::AbstractGrid; save_vals=Val(false), parallel=Val(false))</code></pre><p>Here, <code>grid</code> could be either a <code>RegularGrid</code> or an <code>IrregularGrid</code>. You can set <code>save_vals=Val(true)</code> if you want an array with all the likelihood function values, <code>Val(false)</code> otherwise. To enable multithreading, allowing for the evaluation of the function across different points via multiple threads, set <code>parallel=Val(true)</code>, otherwise leave it as <code>Val(false)</code>. The result of this grid search, if <code>save_vals=Val(true)</code>, will be <code>(sol, f_vals)</code>, where <code>sol</code> is a likelihood solution giving the parameters that gave to the highest likelihood, and <code>f_res</code> is the array of likelihoods at the corresponding parameters. If <code>save_vals=Val(false)</code>, only <code>sol</code> is returned.</p><p>More example is given in the examples, and complete docstrings are provided in the sidebar.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../docstrings/">Docstrings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 23 December 2022 07:05">Friday 23 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
